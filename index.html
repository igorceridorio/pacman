<!-- 
	UNIVERSITY OF NEBRASKA AT KEARNEY
	COMPUTER GRAPHICS - Threejs PROJECT

	Igor Felipe Ferreira CeridÃ³rio	
 -->


<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Pacman Three.js!</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="shortcut icon" href="img/icon.png">
	</head>

	<body>
		<div id="container"></div>
		
		
		<!-- PLAYING CONTROLS INFORMATION  -->
		<div id="info">

			<p> PAC MAN Three.js EDITION! - Sound: <a href='javascript:soundOn()'> on</a> /  <a href='javascript:soundOff()'> off </a> </p>
		</div>

		<link rel="stylesheet" type="text/css" href="styles/pagestyle.css">
		<link rel="stylesheet" type="text/css" href="styles/sweetalert.css">

		<script src="lib/three.min.js"></script>
		<script src="lib/TrackballControls.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/threex.pacman.js"></script>
		<script src="lib/sweetalert.min.js"></script>

		<!-- FOOTER OF THE PAGE -->
		<div id="wrapper">
			<div id="footer">
				
				<div id="arrows">
					<p><img src="img/up.png" height="30" width="30" id="upArrow" oncontextmenu="return false" ></p>
					<p><img src="img/left.png" height="30" width="30" id="leftArrow" oncontextmenu="return false" >
					<img src="img/right.png" height="30" width="30" id="rightArrow" oncontextmenu="return false" ></p>
					<p><img src="img/down.png" height="30" width="30" id="downArrow" oncontextmenu="return false" ></p>
				</div>

				<div id="footerInfo">
					<p id ="guide"> <font color="red">[W, S, A, D] - </font> Control Pacman (Arrows for touchable devices); </p>
					<p id ="guide"> <font color="red">[Scroll] - </font> Zoom; <font color="red">[Left click] - </font> Rotate; <font color="red">[Right click] - </font> Move camera; </p>
				</div>

			</div>
		</div>

		<script>

			// audio flag controller
			var playAudio = true;

			// background game music
			var bgAudio = new Audio();
			if(bgAudio.canPlayType("audio/mp3"))
				bgAudio.src = "music/bg.mp3"
			else if(bgAaudio.canPlayType("audio/ogg"))
				bgAudio.src = "music/bg.ogg"
			bgAudio.volume = 0.7;

			// add the listener to put the background music on loop
			bgAudio.addEventListener('ended', function() {
		    	this.currentTime = 0;
    			this.play();
			}, false);
			soundOn();

			// pacman chomp game music
			var pacAudio = new Audio();
			if(pacAudio.canPlayType("audio/mp3"))
				pacAudio.src = "music/chomp.mp3"
			else if(pacAudio.canPlayType("audio/ogg"))
				pacAudio.src = "music/chomp.ogg"
			pacAudio.volume = 0.5;

			// winning game music
			var winAudio = new Audio();
			if(winAudio.canPlayType("audio/mp3"))
				winAudio.src = "music/win.mp3"
			else if(winAudio.canPlayType("audio/ogg"))
				winAudio.src = "music/win.ogg"

			// death game music
			var deathAudio = new Audio();
			if(deathAudio.canPlayType("audio/mp3"))
				deathAudio.src = "music/death.mp3"
			else if(deathAudio.canPlayType("audio/ogg"))
				winAudio.src = "music/death.ogg"

			var container, stats;
			var camera, controls, scene, renderer;
			var cross;

			// variables used to track point of the current drawing area
			var xPos = -25, yPos = 10, zPos = 0;

			// pacman position variables
			var xPosPacman, yPosPacman;

			// ghosts position variables
			var xGhostOne, yGhostOne;
			var xGhostTwo, yGhostTwo;
			var xGhostThree, yGhostThree;
			var xGhostFour, yGhostFour;

			// variable used to keep track of how many spheres are left to be eaten by pacman
			var numSphere = 0;

			// variable used to determine whether pacman is allowed to move or not
			var pacCanMove = 1;

			// variable used to create a delay on the key press events
			var keyPress = 0;

			/* two dimensional array used to keep track of all the points on the maze 
			 * 0 - indicates a wall, neither ghosts nor pacman are able to move to these positions
			 * 1 - indicates a sphere, pacman is able to eat it when hits these positions
			 * 2 - indicates a position where the ghosts can walk but pacman can't (ghosts 'home')
			*/
			var posMatrix = [];
			for(var line = 0; line < 20; line++) {
				posMatrix[line] = [];
				for(var col = 0; col < 50; col++){
					posMatrix[line][col] = [];
				}
			}

			// ---------------------------------------------
			// pacman and the ghosts
			// ---------------------------------------------

			var pacman = new THREEx.Pacman( {text: ''} );
			pacman.rotation.x = degreesToRadians(90);
			pacman.scale.set(0.8, 0.8, 0.8);

			var ghostOne = new THREEx.Pacman ({
				shape: 'ghost',
				text: '',
				color: '#FA0B0B'
			});
			ghostOne.rotation.x = degreesToRadians(90);
			ghostOne.scale.set(0.8, 0.8, 0.8);

			var ghostTwo = new THREEx.Pacman ({
				shape: 'ghost',
				text: '',
				color: '#80F24B'
			});
			ghostTwo.rotation.x = degreesToRadians(90);
			ghostTwo.scale.set(0.8, 0.8, 0.8);

			var ghostThree = new THREEx.Pacman ({
				shape: 'ghost',
				text: '',
				color: '#F5902C'
			});
			ghostThree.rotation.x = degreesToRadians(90);
			ghostThree.scale.set(0.8, 0.8, 0.8);

			var ghostFour = new THREEx.Pacman ({
				shape: 'ghost',
				text: '',
				color: '#2C5BF5'
			});
			ghostFour.rotation.x = degreesToRadians(90);
			ghostFour.scale.set(0.8, 0.8, 0.8);

			// call the function to init the game
			init();

			// call the function to animate the scene
			animate();

			function init() {

				
				// -------------------------------------------------------------------------------------------
				// CAMERA
				// -------------------------------------------------------------------------------------------

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.z = 32.5;
				camera.position.y = -12.5;

				// -------------------------------------------------------------------------------------------
				// MOUSE CONTROLS
				// -------------------------------------------------------------------------------------------

				controls = new THREE.TrackballControls( camera );

				controls.rotateSpeed = 3.0;
				controls.zoomSpeed = 3.2;
				controls.panSpeed = 3.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener( 'change', render );

				// -------------------------------------------------------------------------------------------
				// WORLD CONSTRUCTION
				// -------------------------------------------------------------------------------------------

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0xCAC2C2, 0.002 );

				var geometryCube = new THREE.BoxGeometry( 1, 1, 1);
				var materialCube =  new THREE.MeshPhongMaterial( { color:0xfffff, shading: THREE.FlatShading } );
				var cube;

				var geometrySphere = new THREE.SphereGeometry(0.2, 32, 32);
				var materialSphere = new THREE.MeshPhongMaterial( {color: 0xffffff, shading: THREE.FlatShading} );
				var sphere;


				// ---------------------------------------------
				// maze generation
				// ---------------------------------------------

				// 1st line
				line = 0; col = 0;
				for(var i = 0; i < 50; i++) {
					genMazeLine(1);
					col++;
				}

				// 2nd line
				line ++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 0 || i == 49)
						genMazeLine(1);
					else
						genMazeLine(0);
					col++;
				}

				// 3rd line
				line ++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 12 || i == 23 || i == 26 || i == 37 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 4th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 12 || i == 23 || i == 26 || i == 37 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 5th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || (i >= 12 && i <= 23) || (i >= 26 && i <= 37) || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 6th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 16 || i == 23 || i == 26 || i == 33 || i == 37 || i == 48)
						genMazeLine(0);
					else if(i == 12){
						// pacman initial position
						xPosPacman = xPos;
						yPosPacman = yPos;
						pacman.position.x = xPos; 
						pacman.position.y = yPos; 
						pacman.position.z = zPos;						
						pacman.updateMatrix();
						pacman.matrixAutoUpdate = false;
						scene.add(pacman);
						xPos += 1;
						//pacman and ghosts are able to move here, but there is no sphere in this position
						posMatrix[line][col] = 1;
					} else
						genMazeLine(1);
					col++;
				}

				// 7th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if((i >= 1 && i <= 12) || i == 16 ||  i == 23 || i == 26 || i == 33 || (i >= 37 && i <= 48))
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 8th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 5 || i == 8 || i == 12 || i == 16 || (i >= 19 && i <= 30) || i == 33 || i == 37
						 || i == 41 || i == 44 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 9th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 5 || i == 8 || i == 12 || (i >= 16 && i <= 19) || (i >= 30 && i <= 33) || i == 37 
						|| i == 41 || i == 44 || i == 48)
						genMazeLine(0);
					else if(i == 24 || i == 25) {
						//ghosts can walk here but pacman can't
						posMatrix[line][col] = 2;
						xPos += 1;
					} else
						genMazeLine(1);
					col++;
				}

				// 10th line
				line ++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if((i >= 1 && i <= 5) || (i >= 8 && i <= 12) || i == 16 || i == 19 || i == 30 || i == 33 || 
						 (i >= 37 && i <= 41) || (i >= 44 && i <= 48))
						genMazeLine(0);
					else if(i == 21 || i == 22 || (i >= 24 && i <= 26) || i == 28){
						xPos += 1;
						//ghosts can walk here but pacman can't
						posMatrix[line][col] = 2;
					} else if(i == 23){
						// ghost one initial position
						xGhostOne = xPos;
						yGhostOne = yPos;
						ghostOne.position.x = xPos; 
						ghostOne.position.y = yPos; 
						ghostOne.position.z = zPos;						
						ghostOne.updateMatrix();
						ghostOne.matrixAutoUpdate = false;
						scene.add(ghostOne);
						xPos += 1;
						//ghosts can walk here but pacman can't
						posMatrix[line][col] = 2;
					} else if(i == 27){
						// ghost two initial position
						xGhostTwo = xPos;
						yGhostTwo = yPos;
						ghostTwo.position.x = xPos; 
						ghostTwo.position.y = yPos; 
						ghostTwo.position.z = zPos;						
						ghostTwo.updateMatrix();
						ghostTwo.matrixAutoUpdate = false;
						scene.add(ghostTwo);
						xPos += 1;
						//ghosts can walk here but pacman can't
						posMatrix[line][col] = 2;
					} else
						genMazeLine(1);
					col++;
				}

				// 11th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 5 || i == 8 || i == 12 || i == 16 || i == 19 || i == 30 || i == 33 || i == 37 
						 || i == 41 || i == 44 || i == 48)
						genMazeLine(0);
					else if(i == 21 || i == 23 || i == 24 || (i >= 26 && i <= 28)) {
						xPos += 1;
						//ghosts can walk here but pacman can't
						posMatrix[line][col] = 2;
					} else if(i == 22){
						// ghost three initial position
						xGhostThree = xPos;
						yGhostThree = yPos;
						ghostThree.position.x = xPos; 
						ghostThree.position.y = yPos; 
						ghostThree.position.z = zPos;						
						ghostThree.updateMatrix();
						ghostThree.matrixAutoUpdate = false;
						scene.add(ghostThree);
						xPos += 1;
						//ghosts can walk here but pacman can't
						posMatrix[line][col] = 2;
					} else if(i == 25){
						// ghost four initial position
						xGhostFour = xPos;
						yGhostFour = yPos;
						ghostFour.position.x = xPos; 
						ghostFour.position.y = yPos; 
						ghostFour.position.z = zPos;						
						ghostFour.updateMatrix();
						ghostFour.matrixAutoUpdate = false;
						scene.add(ghostFour);
						xPos += 1;
						//ghosts can walk here but pacman can't
						posMatrix[line][col] = 2;
					} else
						genMazeLine(1);
					col++;
				}

				// 12th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 5 || i == 8 || i == 12 || i == 16 || i == 19 || i == 30 || i == 33
						 || i == 37 || i == 41 || i == 44 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 13th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 5 || i == 8 || i == 12 || (i >= 16 && i <= 33) || i == 37 || i == 41 
						|| i == 44 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 14th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if((i >= 1 && i <= 12) || i == 16 || i == 19 || i == 30 || i == 33 || (i >= 37 && i <= 48))
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 15th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 12 || i == 16 || (i >= 19 && i <= 30) || i == 33 || i == 37 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 16th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 12 || i == 16 || i == 22 || i == 27 || i == 33 || i == 37 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 17th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 12 || i == 16 || i == 22 || i == 27 || i == 33 || i == 37 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 18th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 1 || i == 12 || i == 16 || i == 22 || i == 27 || i == 33 || i == 37 || i == 48)
						genMazeLine(0);
					else
						genMazeLine(1);
					col++;
				}

				// 19th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					if(i == 0 || i == 49)
						genMazeLine(1);
					else
						genMazeLine(0);
					col++;
				}

				// 20th line
				line++; col = 0;
				updateMazeGenPos();
				for(var i = 0; i < 50; i++) {
					genMazeLine(1);
					col++;
				}

				// -------------------------------------------------------------------------------------------
				// LIGHTS DEFINITION
				// -------------------------------------------------------------------------------------------

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.add( light );

				light = new THREE.DirectionalLight( 0x4D879E );
				light.position.set( -1, -1, -1 );
				scene.add( light );

				light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );


				// -------------------------------------------------------------------------------------------
				// RENDERER
				// -------------------------------------------------------------------------------------------

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				// -------------------------------------------------------------------------------------------
				// LISTENERS
				// -------------------------------------------------------------------------------------------

				// resize listener
				window.addEventListener( 'resize', onWindowResize, false );

				// keyboard listeners
				window.addEventListener( 'keydown', onKeyDown, false );
				window.addEventListener('keyup', onKeyUp, false);

				// touch listeners
				var upTouchElement = document.getElementById("upArrow");
				upArrow.addEventListener("touchend", upArrowTouch, false);
				
				var leftTouchElement = document.getElementById("leftArrow");
				leftArrow.addEventListener("touchend", leftArrowTouch, false);
				
				var downTouchElement = document.getElementById("downArrow");
				downArrow.addEventListener("touchend", downArrowTouch, false);

				var rightTouchElement = document.getElementById("rightArrow");
				rightArrow.addEventListener("touchend", rightArrowTouch, false);

				// -------------------------------------------------------------------------------------------
				// GHOSTS MOVEMENT TRIGGER
				// -------------------------------------------------------------------------------------------

				ghostOneMovement();
				ghostTwoMovement();
				ghostThreeMovement();
				ghostFourMovement();

				// call the colision function
				collisionPacmanGhost();

				// call the first rendering
				render();

				// ---------------------------------------------
				// ghost one movement function
				// ---------------------------------------------
				var iOne = 0; // counter variable
				var jOne = 0;  // this variable is responsible for determing the max steps of direction
				var flagOne = 0; // flag used to verify when is necessary to create another random
				var dirOne; // random direction to where the ghost should move
				function ghostOneMovement() {
					// hardcoded initial movements to set the ghost in the desired initial place
					if(iOne == 0) {
						movGhostOneD(0);
						iOne++;
					} else if(iOne == 1) {
						movGhostOneW(0);
						iOne++;
					} else if(iOne == 2) {
						movGhostOneW(0);
						iOne++;
					} else {
						// generate a random number to set the direction movement
						if(flagOne == 0) {
							dirOne = genRandomNumber();
							flagOne = 1;
						}

						// if j hits the limit change the direction of the ghost
						if(jOne == 4){
							jOne = 0;
							flagOne = 0;
						}

						// moves ghost to the generated direction until it hits a wall
						if(flagOne == 1) {
							if(dirOne == 1){
								if(!movGhostOneW(1)){
									flagOne = 0;
								}
								jOne++;
							}
							if(dirOne == 2){
								if(!movGhostOneA(1)){
									flagOne = 0;
								}
								jOne++;
							}
							if(dirOne == 3){
								if(!movGhostOneS(1)){
									flagOne = 0;
								}
								jOne++;
							}
							if(dirOne == 4){
								if(!movGhostOneD(1)){
									flagOne = 0;
								}
								jOne++;
							}
						}
					}

					// call recursevely the function to keep ghost moving
					setTimeout(ghostOneMovement, 100);
				}

				// ---------------------------------------------
				// ghost one auxiliary functions
				// ---------------------------------------------
				function movGhostOneW(flag) {
					if(posMatrix[(10 - ghostOne.position.y) - 1][(ghostOne.position.x + 25)] == 1 && flag == 1) {
						ghostOne.position.y = yGhostOne + 1;
						yGhostOne = ghostOne.position.y;
						ghostOne.updateMatrix();
						render();
						return true;
					} else if(flag == 0) {
						ghostOne.position.y = yGhostOne + 1;
						yGhostOne = ghostOne.position.y;
						ghostOne.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostOneS(flag) {
					if(posMatrix[(10 - ghostOne.position.y) + 1][(ghostOne.position.x + 25)] == 1 && flag == 1) {
						ghostOne.position.y = yGhostOne - 1;
						yGhostOne = ghostOne.position.y;
						ghostOne.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostOne.position.y = yGhostOne - 1;
						yGhostOne = ghostOne.position.y;
						ghostOne.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostOneD(flag) {
					if(posMatrix[(10 - ghostOne.position.y)][(ghostOne.position.x + 25) + 1] == 1 && flag == 1) {
						ghostOne.position.x = xGhostOne + 1;
						xGhostOne = ghostOne.position.x;
						ghostOne.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostOne.position.x = xGhostOne + 1;
						xGhostOne = ghostOne.position.x;
						ghostOne.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostOneA(flag) {
					if(posMatrix[(10 - ghostOne.position.y)][(ghostOne.position.x + 25) - 1] == 1 && flag == 1) {
						ghostOne.position.x = xGhostOne - 1;
						xGhostOne = ghostOne.position.x;
						ghostOne.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostOne.position.x = xGhostOne - 1;
						xGhostOne = ghostOne.position.x;
						ghostOne.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				// ---------------------------------------------
				// ghost two movement function
				// ---------------------------------------------
				var iTwo = 0; // counter variable
				var jTwo = 0;  // this variable is responsible for determing the max steps of direction
				var flagTwo = 0; // flag used to verify when is necessary to create another random
				var dirTwo; // random direction to where the ghost should move
				function ghostTwoMovement() {
					// hardcoded initial movements to set the ghost in the desired initial place
					if(iTwo == 0) {
						movGhostTwoA(0);
						iTwo++;
					} else if(iTwo == 1) {
						movGhostTwoA(0);
						iTwo++;
					} else if(iTwo == 2) {
						movGhostTwoW(0);
						iTwo++;
					} else if(iTwo == 3) {
						movGhostTwoW(0);
						iTwo++; 
					} else if(iTwo == 4) {
						movGhostTwoD(0);
						iTwo++; 
					} else if(iTwo == 5) {
						movGhostTwoW(0);
						iTwo++; 
					} else if(iTwo == 6) {
						movGhostTwoW(0);
						iTwo++; 
					} else if(iTwo == 7) {
						movGhostTwoW(0);
						iTwo++; 
					} else if(iTwo == 8) {
						movGhostTwoW(0);
						iTwo++; 
					} else if(iTwo == 9) {
						movGhostTwoW(0);
						iTwo++; 
					} else {
						// generate a random number to set the direction movement
						if(flagTwo == 0) {
							dirTwo = genRandomNumber();
							flagTwo = 1;
						}

						// if j hits the limit change the direction of the ghost
						if(jTwo == 6){
							jTwo = 0;
							flagTwo = 0;
						}

						// moves ghost to the generated direction until it hits a wall
						if(flagTwo == 1) {
							if(dirTwo == 1){
								if(!movGhostTwoW(1)){
									flagTwo = 0;
								}
								jTwo++;
							}
							if(dirTwo == 2){
								if(!movGhostTwoA(1)){
									flagTwo = 0;
								}
								jTwo++;
							}
							if(dirTwo == 3){
								if(!movGhostTwoS(1)){
									flagTwo = 0;
								}
								jTwo++;
							}
							if(dirTwo == 4){
								if(!movGhostTwoD(1)){
									flagTwo = 0;
								}
								jTwo++;
							}
						}
					}

					// call recursevely the function to keep ghost moving
					setTimeout(ghostTwoMovement, 100);
				}

				// ---------------------------------------------
				// ghost two auxiliary functions
				// ---------------------------------------------
				function movGhostTwoW(flag) {
					if(posMatrix[(10 - ghostTwo.position.y) - 1][(ghostTwo.position.x + 25)] == 1 && flag == 1) {
						ghostTwo.position.y = yGhostTwo + 1;
						yGhostTwo = ghostTwo.position.y;
						ghostTwo.updateMatrix();
						render();
						return true;
					} else if(flag == 0) {
						ghostTwo.position.y = yGhostTwo + 1;
						yGhostTwo = ghostTwo.position.y;
						ghostTwo.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostTwoS(flag) {
					if(posMatrix[(10 - ghostTwo.position.y) + 1][(ghostTwo.position.x + 25)] == 1 && flag == 1) {
						ghostTwo.position.y = yGhostTwo - 1;
						yGhostTwo = ghostTwo.position.y;
						ghostTwo.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostTwo.position.y = yGhostTwo - 1;
						yGhostTwo = ghostTwo.position.y;
						ghostTwo.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostTwoD(flag) {
					if(posMatrix[(10 - ghostTwo.position.y)][(ghostTwo.position.x + 25) + 1] == 1 && flag == 1) {
						ghostTwo.position.x = xGhostTwo + 1;
						xGhostTwo = ghostTwo.position.x;
						ghostTwo.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostTwo.position.x = xGhostTwo + 1;
						xGhostTwo = ghostTwo.position.x;
						ghostTwo.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostTwoA(flag) {
					if(posMatrix[(10 - ghostTwo.position.y)][(ghostTwo.position.x + 25) - 1] == 1 && flag == 1) {
						ghostTwo.position.x = xGhostTwo - 1;
						xGhostTwo = ghostTwo.position.x;
						ghostTwo.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostTwo.position.x = xGhostTwo - 1;
						xGhostTwo = ghostTwo.position.x;
						ghostTwo.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				// ---------------------------------------------
				// ghost three movement function
				// ---------------------------------------------
				var iThree = 0; // counter variable
				var jThree = 0;  // this variable is responsible for determing the max steps of direction
				var flagThree = 0; // flag used to verify when is necessary to create another random
				var dirThree; // random direction to where the ghost should move
				function ghostThreeMovement() {
					// hardcoded initial movements to set the ghost in the desired initial place
					if(iThree == 0) {
						movGhostThreeW(0);
						iThree++;
					} else if(iThree == 1) {
						movGhostThreeD(0);
						iThree++;
					} else if(iThree == 2) {
						movGhostThreeD(0);
						iThree++;
					} else if(iThree == 3) {
						movGhostThreeW(0);
						iThree++;
					}else if(iThree == 4) {
						movGhostThreeW(0);
						iThree++;
					} else if(iThree == 5) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 6) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 7) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 8) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 9) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 10) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 11) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 12) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 13) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 14) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 15) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 16) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 17) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 18) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 19) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 20) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 21) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 22) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 23) {
						movGhostThreeS(0);
						iThree++;
					} else if(iThree == 24) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 25) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 26) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 27) {
						movGhostThreeA(0);
						iThree++;
					} else if(iThree == 28) {
						movGhostThreeW(0);
						iThree++;
					} else if(iThree == 29) {
						movGhostThreeW(0);
						iThree++;
					} else {
						// generate a random number to set the direction movement
						if(flagThree == 0) {
							dirThree = genRandomNumber();
							flagThree = 1;
						}

						// if j hits the limit change the direction of the ghost
						if(jThree == 8){
							jThree = 0;
							flagThree = 0;
						}

						// moves ghost to the generated direction until it hits a wall
						if(flagThree == 1) {
							if(dirThree == 1){
								if(!movGhostThreeW(1)){
									flagThree = 0;
								}
								jThree++;
							}
							if(dirThree == 2){
								if(!movGhostThreeA(1)){
									flagThree = 0;
								}
								jThree++;
							}
							if(dirThree == 3){
								if(!movGhostThreeS(1)){
									flagThree = 0;
								}
								jThree++;
							}
							if(dirThree == 4){
								if(!movGhostThreeD(1)){
									flagThree = 0;
								}
								jThree++;
							}
						}
					}

					// call recursevely the function to keep ghost moving
					setTimeout(ghostThreeMovement, 100);

				}

				// ---------------------------------------------
				// ghost three auxiliary functions
				// ---------------------------------------------
				function movGhostThreeW(flag) {
					if(posMatrix[(10 - ghostThree.position.y) - 1][(ghostThree.position.x + 25)] == 1 && flag == 1) {
						ghostThree.position.y = yGhostThree + 1;
						yGhostThree = ghostThree.position.y;
						ghostThree.updateMatrix();
						render();
						return true;
					} else if(flag == 0) {
						ghostThree.position.y = yGhostThree + 1;
						yGhostThree = ghostThree.position.y;
						ghostThree.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostThreeS(flag) {
					if(posMatrix[(10 - ghostThree.position.y) + 1][(ghostThree.position.x + 25)] == 1 && flag == 1) {
						ghostThree.position.y = yGhostThree - 1;
						yGhostThree = ghostThree.position.y;
						ghostThree.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostThree.position.y = yGhostThree - 1;
						yGhostThree = ghostThree.position.y;
						ghostThree.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostThreeD(flag) {
					if(posMatrix[(10 - ghostThree.position.y)][(ghostThree.position.x + 25) + 1] == 1 && flag == 1) {
						ghostThree.position.x = xGhostThree + 1;
						xGhostThree = ghostThree.position.x;
						ghostThree.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostThree.position.x = xGhostThree + 1;
						xGhostThree = ghostThree.position.x;
						ghostThree.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostThreeA(flag) {
					if(posMatrix[(10 - ghostThree.position.y)][(ghostThree.position.x + 25) - 1] == 1 && flag == 1) {
						ghostThree.position.x = xGhostThree - 1;
						xGhostThree = ghostThree.position.x;
						ghostThree.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostThree.position.x = xGhostThree - 1;
						xGhostThree = ghostThree.position.x;
						ghostThree.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				// ---------------------------------------------
				// ghost four movement function
				// ---------------------------------------------
				var iFour = 0; // counter variable
				var jFour = 0;  // this variable is responsible for determing the max steps of direction
				var flagFour = 0; // flag used to verify when is necessary to create another random
				var dirFour; // random direction to where the ghost should move
				function ghostFourMovement() {
					// hardcoded initial movements to set the ghost in the desired initial place
					if(iFour == 0) {
						movGhostFourW(0);
						iFour++;
					} else if(iFour == 1) {
						movGhostFourW(0);
						iFour++;
					} else if(iFour == 2) {
						movGhostFourW(0);
						iFour++;
					} else {
						// generate a random number to set the direction movement
						if(flagFour == 0) {
							dirFour = genRandomNumber();
							flagFour = 1;
						}

						// if j hits the limit change the direction of the ghost
						if(jFour == 10){
							jFour = 0;
							flagFour = 0;
						}

						// moves ghost to the generated direction until it hits a wall
						if(flagFour == 1) {
							if(dirFour == 1){
								if(!movGhostFourW(1)){
									flagFour = 0;
								}
								jFour++;
							}
							if(dirFour == 2){
								if(!movGhostFourA(1)){
									flagFour = 0;
								}
								jFour++;
							}
							if(dirFour == 3){
								if(!movGhostFourS(1)){
									flagFour = 0;
								}
								jFour++;
							}
							if(dirFour == 4){
								if(!movGhostFourD(1)){
									flagFour = 0;
								}
								jFour++;
							}
						}
					}

					// call recursevely the function to keep ghost moving
					setTimeout(ghostFourMovement, 100);
				}

				// ---------------------------------------------
				// ghost four auxiliary functions
				// ---------------------------------------------
				function movGhostFourW(flag) {
					if(posMatrix[(10 - ghostFour.position.y) - 1][(ghostFour.position.x + 25)] == 1 && flag == 1) {
						ghostFour.position.y = yGhostFour + 1;
						yGhostFour = ghostFour.position.y;
						ghostFour.updateMatrix();
						render();
						return true;
					} else if(flag == 0) {
						ghostFour.position.y = yGhostFour + 1;
						yGhostFour = ghostFour.position.y;
						ghostFour.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostFourS(flag) {
					if(posMatrix[(10 - ghostFour.position.y) + 1][(ghostFour.position.x + 25)] == 1 && flag == 1) {
						ghostFour.position.y = yGhostFour - 1;
						yGhostFour = ghostFour.position.y;
						ghostFour.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostFour.position.y = yGhostFour - 1;
						yGhostFour = ghostFour.position.y;
						ghostFour.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostFourD(flag) {
					if(posMatrix[(10 - ghostFour.position.y)][(ghostFour.position.x + 25) + 1] == 1 && flag == 1) {
						ghostFour.position.x = xGhostFour + 1;
						xGhostFour = ghostFour.position.x;
						ghostFour.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostFour.position.x = xGhostFour + 1;
						xGhostFour = ghostFour.position.x;
						ghostFour.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				function movGhostFourA(flag) {
					if(posMatrix[(10 - ghostFour.position.y)][(ghostFour.position.x + 25) - 1] == 1 && flag == 1) {
						ghostFour.position.x = xGhostFour - 1;
						xGhostFour = ghostFour.position.x;
						ghostFour.updateMatrix();
						render();
						return true;
					} else if (flag == 0) {
						ghostFour.position.x = xGhostFour - 1;
						xGhostFour = ghostFour.position.x;
						ghostFour.updateMatrix();
						render();
						return true;
					}
					return false;
				}

				// ---------------------------------------------
				// maze generation auxiliary function
				// ---------------------------------------------
				function genMazeLine(flag) {
					if(flag == 1) {
						cube = new THREE.Mesh(geometryCube, materialCube);
						cube.position.x = xPos; 
						cube.position.y = yPos; 
						cube.position.z = zPos;
						cube.updateMatrix();
						cube.matrixAutoUpdate = false;
						scene.add(cube);
						// none of the charactes are able to move to this position
						posMatrix[line][col] = 0;
					} else {
						var sName = 's' + xPos.toString() + yPos.toString();
						sphere = new THREE.Mesh(geometrySphere, materialSphere);
						sphere.position.x = xPos; 
						sphere.position.y = yPos; 
						sphere.position.z = zPos;
						sphere.updateMatrix();
						sphere.matrixAutoUpdate = false;
						scene.add(sphere);
						// pacman and the ghosts can move to this position
						posMatrix[line][col] = 1;
						sphere.name = sName;
						numSphere += 1;
					}
					xPos += 1;
				}

				// ---------------------------------------------
				// sphere deletion function
				// ---------------------------------------------				
				function deleteSphere(sName) {
					var obj = scene.getObjectByName(sName);
					if(obj != undefined) {
						numSphere -= 1;
						scene.remove(obj);
						if(playAudio)
							pacAudio.play();
						if(numSphere == 0) {
							// stop the bg music and triggers the win music
							bgAudio.pause();
							if(playAudio)
								winAudio.play();
							pacCanMove = 0;
							// spawn the alert
							swal({
								title: "The end!",   
								text: "You ate all the spheres :)",   
								type: "success",   
								showCancelButton: false,   
								confirmButtonColor: "#2D7524",   
								confirmButtonText: "Play again!",   
								closeOnConfirm: true }, 
							function(){   
									// reload the page to start a new game
									location.reload();
							});
						}
					}
				}

				// ---------------------------------------------
				// touches movement handler functions
				// ---------------------------------------------
				function upArrowTouch(event) {
					if(posMatrix[(10 - pacman.position.y) - 1][(pacman.position.x + 25)] == 1) {
						pacman.position.y = yPosPacman + 1;
						yPosPacman = pacman.position.y;
						pacman.updateMatrix();
						var sName = 's' + pacman.position.x.toString() + pacman.position.y.toString();
						deleteSphere(sName);
						render();
					}

				}

				function leftArrowTouch(event) {
					if(posMatrix[(10 - pacman.position.y)][(pacman.position.x + 25) - 1] == 1) {
						pacman.position.x = xPosPacman - 1;
						xPosPacman = pacman.position.x;
						pacman.updateMatrix();
						var sName = 's' + pacman.position.x.toString() + pacman.position.y.toString();
						deleteSphere(sName);
						render();
					}
				}

				function downArrowTouch(event) {
					if(posMatrix[(10 - pacman.position.y) + 1][(pacman.position.x + 25)] == 1) {
						pacman.position.y = yPosPacman - 1;
						yPosPacman = pacman.position.y;
						pacman.updateMatrix();
						var sName = 's' + pacman.position.x.toString() + pacman.position.y.toString();
						deleteSphere(sName);
						render();
					}
				}

				function rightArrowTouch(event) {
					if(posMatrix[(10 - pacman.position.y)][(pacman.position.x + 25) + 1] == 1) {
						pacman.position.x = xPosPacman + 1;
						xPosPacman = pacman.position.x;
						pacman.updateMatrix();
						var sName = 's' + pacman.position.x.toString() + pacman.position.y.toString();
						deleteSphere(sName);
						render();
					}
				}

				// ---------------------------------------------
				// keys movement handler function
				// ---------------------------------------------
				function onKeyDown(event) {
					var key = event.keyCode;

					if(pacCanMove == 1) {
						switch(key) {
							case 87: // w key
								if(posMatrix[(10 - pacman.position.y) - 1][(pacman.position.x + 25)] == 1 && keyPress >= 1) {
									pacman.position.y = yPosPacman + 1;
									yPosPacman = pacman.position.y;
									pacman.updateMatrix();
									var sName = 's' + pacman.position.x.toString() + pacman.position.y.toString();
									deleteSphere(sName);
									render();
									keyPress = 0;
								}
								keyPress++;
								break;
							case 65: // a key
								if(posMatrix[(10 - pacman.position.y)][(pacman.position.x + 25) - 1] == 1 && keyPress >= 1) {
									pacman.position.x = xPosPacman - 1;
									xPosPacman = pacman.position.x;
									pacman.updateMatrix();
									var sName = 's' + pacman.position.x.toString() + pacman.position.y.toString();
									deleteSphere(sName);
									render();
									keyPress = 0;
								}
								keyPress++;
								break;
							case 83: // s key
								if(posMatrix[(10 - pacman.position.y) + 1][(pacman.position.x + 25)] == 1 && keyPress >= 1) {
									pacman.position.y = yPosPacman - 1;
									yPosPacman = pacman.position.y;
									pacman.updateMatrix();
									var sName = 's' + pacman.position.x.toString() + pacman.position.y.toString();
									deleteSphere(sName);
									render();
									keyPress = 0;
								}
								keyPress++;
								break;
							case 68: // d key
								if(posMatrix[(10 - pacman.position.y)][(pacman.position.x + 25) + 1] == 1 && keyPress >= 1) {
									pacman.position.x = xPosPacman + 1;
									xPosPacman = pacman.position.x;
									pacman.updateMatrix();
									var sName = 's' + pacman.position.x.toString() + pacman.position.y.toString();
									deleteSphere(sName);
									render();
									keyPress = 0;
								}
								keyPress++;
								break;
							default:
								break;
						}
					}
				}

				function onKeyUp(event) {
					keyPress = 1;
				}

				// ---------------------------------------------
				// ghost collision with pacman function
				// ---------------------------------------------
				function collisionPacmanGhost() {
					if(((xPosPacman == xGhostOne) && (yPosPacman == yGhostOne)) 
						|| ((xPosPacman == xGhostTwo) && (yPosPacman == yGhostTwo))
						|| ((xPosPacman == xGhostThree) && (yPosPacman == yGhostThree))
						|| ((xPosPacman == xGhostFour) && (yPosPacman == yGhostFour))) {

						if(pacCanMove == 1) {
							// stop the bg music and triggers the death music
							bgAudio.pause();
							if(playAudio)
								deathAudio.play();
							// spawn the alert
							swal({
								title: "Game Over!",   
								text: "You were hit by a ghost :(",   
								type: "warning",   
								showCancelButton: false,   
								confirmButtonColor: "#DD6B55",   
								confirmButtonText: "Restart!",
								closeOnConfirm: true }, 
							function(){   
									// reload the page to start a new game
									location.reload();
							});
						}
						//pacman is not allowed to move anymore
						pacCanMove = 0;
					}

					// keep calling itself recursevely to check if pacman hit any ghost
					setTimeout(collisionPacmanGhost, 1);
				}

			}
			
			// -------------------------------------------------------------------------------------------
			// WINDOW RESIZE FUNCTION
			// -------------------------------------------------------------------------------------------

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				controls.handleResize();

				render();
			}

			// -------------------------------------------------------------------------------------------
			// ANIMATE FUNCTION
			// -------------------------------------------------------------------------------------------

			function animate() {
				requestAnimationFrame( animate );
				controls.update();
			}

			// -------------------------------------------------------------------------------------------
			// RENDER FUNCTION
			// -------------------------------------------------------------------------------------------

			function render() {
				renderer.render( scene, camera );
				stats.update();
			}

			// -------------------------------------------------------------------------------------------
			// DEGRRES TO RADIANS CONVERSION FUNCTION
			// -------------------------------------------------------------------------------------------

			function degreesToRadians(degree) {
				return degree * (Math.PI / 180);
			}
			
			// -------------------------------------------------------------------------------------------
			// UPDATE POSITION AUXILARY FUNCTION
			// -------------------------------------------------------------------------------------------

			function updateMazeGenPos() {
				xPos = -25;
				yPos -= 1;
			}

			// -------------------------------------------------------------------------------------------
			// 1 ~ 4 RANDOM NUMBER GENERATOR FUNCTION
			// -------------------------------------------------------------------------------------------

			function genRandomNumber() {
				return Math.floor((Math.random() * 4) + 1);
			}

			// -------------------------------------------------------------------------------------------
			// AUDIO ON AND OFF FUNCTIONS
			// -------------------------------------------------------------------------------------------

			function soundOn() {
				playAudio = true;
				bgAudio.play();
			}

			function soundOff() {
				playAudio = false;
				bgAudio.pause();
			}

		</script>

	</body>
</html>
